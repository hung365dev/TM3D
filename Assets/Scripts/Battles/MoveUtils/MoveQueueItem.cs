// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using Battles;
using UnityEngine;
using Items;
using monsters;
using System.Collections;


namespace Battles
{
	public class MoveQueueItem
	{
		private float _speed;
		private float _forcedSpeed = float.MinValue;
		private SelectedMoveData _move;
		private MoveLibItem _useThisMove;
		private MoveLibItem _replaceWithThisMove;
		private BattleMonsterWithMoves _actionMonster;
		
		public delegate void OnMoveQueueItemStatusChange();
		public event OnMoveQueueItemStatusChange onMoveQueueItemChange;
		public bool firstHit = true;
		public EMoveQueueItemStatus status = EMoveQueueItemStatus.Start;
		
		public ETeamPosition targetTeam;
		public EMonsterPos targetMonster;
		
		public BattleTeam actioningTeam;
		public EMonsterPos actionPosition;
		
		public ItemBait baitItem;
		public EMonsterCatchResult baitResult;
		
		public bool followOnMove = false;
		public ITMItem usedItem;
		public byte timesToHit;
		public byte maxTimesToHit;
		public BetterList<BattleMonster> hitMonsters = new BetterList<BattleMonster>();
		public BetterList<BattleMonster> targettedMonster = new BetterList<BattleMonster>();
		public MoveQueueItem(float aSpeed,SelectedMoveData aMoveData,ETeamPosition aTargetTeam,EMonsterPos aTargetMonster,BattleMonsterWithMoves aActionMonster,EMonsterPos aActionMonsterPosition) {
			_speed = aSpeed;
			_move = aMoveData;
			_actionMonster = aActionMonster;
			targetTeam = aTargetTeam;
			targetMonster = aTargetMonster;
			actionPosition = aActionMonsterPosition;
			// Multi hit moves
			timesToHit = 1;
			firstHit = true;

		}
		public bool hasMoveQueueListener {
			get {
				return this.onMoveQueueItemChange!=null;
			}
		}
		public MoveQueueItem(float aSpeed,MoveLibItem aMoveData,ETeamPosition aTargetTeam,EMonsterPos aTargetMonster,EMonsterPos aActionMonsterPosition) {
			_forcedSpeed = aSpeed;
			_useThisMove = aMoveData;
			targetTeam = aTargetTeam;
			targetMonster = aTargetMonster;
			actionPosition = aActionMonsterPosition;
			firstHit = true;
		}
		public MoveQueueItem(ItemBait aBait,EMonsterCatchResult aResult) {
			_forcedSpeed = float.MaxValue;
			_useThisMove = null;
			targetTeam = ETeamPosition.RightTeam;
			targetMonster = EMonsterPos.Unset;
			actionPosition = EMonsterPos.Unset;
			baitItem = aBait;
			baitResult = aResult;
			firstHit = true;
		}
		public MoveQueueItem(ITMItem aItem,BattleMonsterWithMoves aActionMonster) {
			this._actionMonster = aActionMonster;
			_forcedSpeed = float.MaxValue;
			_useThisMove = null;
			targetTeam = ETeamPosition.RightTeam;
			targetMonster = EMonsterPos.Unset;
			actionPosition = EMonsterPos.Unset;
			usedItem = aItem;
			firstHit = true;
		}
		
		public void setTimesToHit() {
		
			if(this.moveData!=null&&this.moveData.minHitsPerTurn>1) {
				float minH = (float) moveData.minHitsPerTurn;
				timesToHit = (byte) Mathf.Ceil( minH*_actionMonster.minMultihitMultiplier );
				if(timesToHit>moveData.maxHitsPerTurn) {
					timesToHit = moveData.maxHitsPerTurn;
				}
				int range = moveData.maxHitsPerTurn-(timesToHit);
				if(range>0) {
					timesToHit += (byte) Mathf.Ceil(BattleRandomizer.random*range);
				}
				maxTimesToHit = timesToHit;
			} else {
				timesToHit = 1;
			}
			
		}
		public void addTargettedMonster(BattleMonster aMonster) {
			for(int i =0;i<this.targettedMonster.size;i++) {
				if(targettedMonster[i]==aMonster) {
					return;
				}
			}
			targettedMonster.Add(aMonster);
		}
		public void addHitMonster(BattleMonster aMonster) {
			for(int i =0;i<this.hitMonsters.size;i++) {
				if(hitMonsters[i]==aMonster) {
					return;
				}
			}
			hitMonsters.Add(aMonster);
		}
		public MoveQueueItem() {
			// This is only called when the user skips a turn, do they ever want to do this?
			_speed = float.MaxValue;
			_move = null;
			firstHit = true;
		}
		
		public BattleMonsterWithMoves actioningMonster {
			get {
				return _actionMonster;
			}
			set {
				_actionMonster = value;
			}
		}
		public MoveLibItem moveData {
			get {
				if(_replaceWithThisMove!=null) {
					return _replaceWithThisMove;
				}
				if(_useThisMove!=null) {
					return _useThisMove;
				}
				if(this._move!=null) {
					return _move.moveData;
				}
				return null;
			}
			set {
				_replaceWithThisMove = value;
			}
		}
		public EMoveQueueItemStatus skipToFinish() {
			// This move couldn't be actioned on further
			this.status = EMoveQueueItemStatus.Finish;
			if(onMoveQueueItemChange!=null) {
				onMoveQueueItemChange();
			} else {
				Debug.LogError("Skipping to finish when no onMoveQueueItemChange was registered");
			}
			return this.status; 
		}
		public EMoveQueueItemStatus advanceMoveQueueFromState(EMoveQueueItemStatus aState) {
			if(this.status==aState) {
				
				CommentaryManager.REF.passiveEffect = null;
				CommentaryManager.REF.battleMonster = null;
				advanceMoveQueue();
				
				
			} else {
//				Debug.Log ("advance move queue from state - wanted: "+aState+" - was: "+this.status);
			}
			return this.status;
		}
		private EMoveQueueItemStatus advanceMoveQueue() {
			if(this.status==EMoveQueueItemStatus.Finish) {
				Debug.Log("Trying to advance finished move queue");
				return EMoveQueueItemStatus.Finish;
			}
		//	Debug.Log("Advancing move queue from: "+this.status);
			switch(this.status) {
				case(EMoveQueueItemStatus.Start):
					this.status = EMoveQueueItemStatus.ChangeToOtherMove;break;
				case(EMoveQueueItemStatus.ChangeToOtherMove):
					this.timesToHit--;
					this.status = EMoveQueueItemStatus.AttackAnimation;
					break;
				case(EMoveQueueItemStatus.AttackAnimation):
					this.status = EMoveQueueItemStatus.HPHits;
					break;
				case(EMoveQueueItemStatus.HPHits):
					this.status = EMoveQueueItemStatus.HPHitsPassiveEffects;break;
				case(EMoveQueueItemStatus.HPHitsPassiveEffects):
					this.status = EMoveQueueItemStatus.StatusEffects;break;
			
				case(EMoveQueueItemStatus.HPBoosts):
					this.status = EMoveQueueItemStatus.StatusBoosts;break;
				case(EMoveQueueItemStatus.StatusEffects):
					this.status = EMoveQueueItemStatus.HPBoosts;
					break;
				
				case(EMoveQueueItemStatus.MoveBackToPosition):
					if(this.timesToHit>1) {
						this.status = EMoveQueueItemStatus.Start;
					} else
					this.status = EMoveQueueItemStatus.InflictMyEffects;
					break;
				case(EMoveQueueItemStatus.InflictMyEffects):
					this.status = EMoveQueueItemStatus.EndMoveQueuePassiveEffects;;
					break;
				case(EMoveQueueItemStatus.EndMoveQueuePassiveEffects):
					this.status = EMoveQueueItemStatus.Finish;
					break;
				case(EMoveQueueItemStatus.StatusBoosts):
					this.status = EMoveQueueItemStatus.StatEffectors;
					break;
				case(EMoveQueueItemStatus.StatEffectors):
					this.status = EMoveQueueItemStatus.MoveBackToPosition;
					break;
			default:Debug.LogError("Unknown state: "+this.status);break;
			}
			
	//		Debug.Log("Move queue is now: "+this.status);
			if(onMoveQueueItemChange!=null) {
				onMoveQueueItemChange();
			} else {
				Debug.LogError("Advancing move queue without a listener");
			}
			return this.status; 
		}
		
		public void cleanUp() {
			_move = null;
			_speed = 0;
		}
		
		public float moveSpeed {
			get {
				if(_move == null || _move.moveData==null) {
					return float.MaxValue;
				}
				if(this._forcedSpeed!=float.MinValue) {
					return this._forcedSpeed;
				}
				return _speed*_move.moveData.moveSpeedMultiplier;
			}
		}
	}
}

