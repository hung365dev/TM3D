// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using Items;


namespace Battles
{
	public class BattleMonsterWithBattleEffects : BattleMonsterWithAnimations
	{
		private float _speedEffector = 1.0f;
		private float _meleeAttackEffector = 1.0f;
		private float _meleeDefenseEffector = 1.0f;
		private float _rangeAttackEffector = 1.0f;
		private float _rangeDefenseEffector = 1.0f;
		private float _accuracyEffector = 1.0f;
		private float _agilityEffector = 1.0f;
		
		public const float MAX_EFFECTOR_VALUE = 2.0f;
		public const float MIN_EFFECTOR_VALUE = 0.25f;
		
		
		public float criticalHitChanceMultiplier = 1f;
		public EMonsterStat invulnerableToChanges = 0;
		public const float delayPerItem = 0.5f;
		
		public BattleMonsterWithBattleEffects ()
		{
			
		}
		public float applyStatEffectsFromMove(MoveLibItem aItem,MoveQueueItem aMoveQueue,PassiveEffect aEffect) {
			return applyStatEffectsFromMove(aItem,aMoveQueue);
		}
			
		private string createStatChangeString(BetterList<string> aStatNames) {
			string r = this.name+" "+aStatNames[0];
			aStatNames.RemoveAt(0);
			while(aStatNames.size>1) {
				r+= ", "+aStatNames[0];
				aStatNames.RemoveAt(0);
			}
			if(aStatNames.size>0) { 
				r += " and "+aStatNames[0];
			}
			return r;
		}
		public float doDecisiveBlowsChange(float aMultiplier) {
			if(aMultiplier>1f) {
				criticalHitChanceMultiplier *= aMultiplier;
				this.doCommentaryMessage(this.name+" Decisive Blows Chance Rose!",ECommentaryMessageType.StandardMessage);
				return delayPerItem;
			}
			return 0f;
		}
		
		public float doAccuracyChange(float aMultiplier,BetterList<string> aImprovedStatsArr,BetterList<string> aDecreasedStatsArr) {
			if(aMultiplier>1.0f&&this._accuracyEffector<MAX_EFFECTOR_VALUE) {
				this._accuracyEffector *= aMultiplier;
				aImprovedStatsArr.Add("Accuracy");
				return delayPerItem;
			} else
			if(aMultiplier<1.0f&&this._accuracyEffector>MIN_EFFECTOR_VALUE) {
				if((EMonsterStat.Accuracy&this.invulnerableToChanges)!=EMonsterStat.Accuracy) {
					this._accuracyEffector *= aMultiplier;
					aDecreasedStatsArr.Add("Accuracy");
				} else {
					this.doCommentaryMessage(this.name+" is Invulnerable to Accuracy Changes",ECommentaryMessageType.StandardMessage);
				}
				return delayPerItem;
			}
			return 0;
		}
		public float doAgilityChange(float aMultiplier,BetterList<string> aImprovedStatsArr,BetterList<string> aDecreasedStatsArr) {
			if(aMultiplier>1.0f&&this._agilityEffector<MAX_EFFECTOR_VALUE) {
				this._agilityEffector *= aMultiplier;
				aImprovedStatsArr.Add("Agility");
				return delayPerItem;
			} else
			if(aMultiplier<1.0f&&this._agilityEffector>MIN_EFFECTOR_VALUE) {
				if((EMonsterStat.Agility&this.invulnerableToChanges)!=EMonsterStat.Agility) {
					this._agilityEffector *= aMultiplier;
					aDecreasedStatsArr.Add ("Agility");
				} else {
					this.doCommentaryMessage(this.name+" is Invulnerable to Agility Changes",ECommentaryMessageType.StandardMessage);
				}
				return delayPerItem;
			}
			return 0;
		}
		public float doMeleeAtckChange(float aMultiplier,BetterList<string> aImprovedStatsArr,BetterList<string> aDecreasedStatsArr) {
			if(aMultiplier>1.0f&&this._meleeAttackEffector<MAX_EFFECTOR_VALUE) {
				this._meleeAttackEffector *= aMultiplier;
				aImprovedStatsArr.Add("Melee Attack");
				return delayPerItem;
			} else
			if(aMultiplier<1.0f&&this._meleeAttackEffector>MIN_EFFECTOR_VALUE) {
				if((EMonsterStat.MeleeAttack&this.invulnerableToChanges)!=EMonsterStat.MeleeAttack) {
					this._meleeAttackEffector *= aMultiplier;
					aDecreasedStatsArr.Add ("Melee Attack");
				} else {
					this.doCommentaryMessage(this.name+" is Invulnerable to Melee Attack Changes",ECommentaryMessageType.StandardMessage);
				}
				return delayPerItem;
			}
			return 0;
		}
		public float doSpeedChange(float aMultiplier,BetterList<string> aImprovedStatsArr,BetterList<string> aDecreasedStatsArr) {
			if(aMultiplier>1.0f&&this._speedEffector<MAX_EFFECTOR_VALUE) {
				this._speedEffector *= aMultiplier;
				aImprovedStatsArr.Add("Speed");
				return delayPerItem;
			} else
			if(aMultiplier<1.0f&&this._speedEffector>MIN_EFFECTOR_VALUE) {
				if((EMonsterStat.Speed&this.invulnerableToChanges)!=EMonsterStat.Speed) {
					this._speedEffector *= aMultiplier;
					
					aDecreasedStatsArr.Add ("Speed");
				} else {
					this.doCommentaryMessage(this.name+" is Invulnerable to Speed Changes",ECommentaryMessageType.StandardMessage);
				}
				return delayPerItem;
			}
			return 0;
		}
		public float doMeleeDefChange(float aMultiplier,BetterList<string> aImprovedStatsArr,BetterList<string> aDecreasedStatsArr) {
			if(aMultiplier>1.0f&&this._meleeDefenseEffector<MAX_EFFECTOR_VALUE) {
				this._meleeDefenseEffector *= aMultiplier;
				aImprovedStatsArr.Add("Melee Defense");
				return delayPerItem;
			} else
			if(aMultiplier<1.0f&&this._meleeDefenseEffector>MIN_EFFECTOR_VALUE) {
				if((EMonsterStat.MeleeDefense&this.invulnerableToChanges)!=EMonsterStat.MeleeDefense) {
					this._meleeDefenseEffector *= aMultiplier;
					aDecreasedStatsArr.Add ("Melee Defense");
				} else {
					this.doCommentaryMessage(this.name+" is Invulnerable to Melee Defense Changes",ECommentaryMessageType.StandardMessage);
				}
				return delayPerItem;
			}
			return 0;
		}
		public float doRangeAtckChange(float aMultiplier,BetterList<string> aImprovedStatsArr,BetterList<string> aDecreasedStatsArr) {
			if(aMultiplier>1.0f&&this._rangeAttackEffector<MAX_EFFECTOR_VALUE) {
				this._rangeAttackEffector *= aMultiplier;
				aImprovedStatsArr.Add("Range Attack");
				return delayPerItem;
			} else
			if(aMultiplier<1.0f&&this._rangeAttackEffector>MIN_EFFECTOR_VALUE) {
				if((EMonsterStat.RangeAttack&this.invulnerableToChanges)!=EMonsterStat.RangeAttack) {
					this._rangeAttackEffector *= aMultiplier;
					aDecreasedStatsArr.Add ("Range Attack");
				} else {
					this.doCommentaryMessage(this.name+" is Invulnerable to Range Attack Changes",ECommentaryMessageType.StandardMessage);
				}
				return delayPerItem;
			}
			return 0;
		}
		
		public float doRangeDefChange(float aMultiplier,BetterList<string> aImprovedStatsArr,BetterList<string> aDecreasedStatsArr) {
			if(aMultiplier>1.0f&&this._rangeDefenseEffector<MAX_EFFECTOR_VALUE) {
				this._rangeDefenseEffector *= aMultiplier;
				aImprovedStatsArr.Add("Range Defense");
				return delayPerItem;
			} else
			if(aMultiplier<1.0f&&this._rangeDefenseEffector>MIN_EFFECTOR_VALUE) {
				if((EMonsterStat.RangeDefense&this.invulnerableToChanges)!=EMonsterStat.RangeDefense) {
					this._rangeDefenseEffector *= aMultiplier;
					aDecreasedStatsArr.Add ("Range Defense");
				} else {
					this.doCommentaryMessage(this.name+" is Invulnerable to Range Defense Changes",ECommentaryMessageType.StandardMessage);
				}
				return delayPerItem;
			}
			return 0;
		}
		
		private bool doInvulnerableToChanges(EMonsterStat aFlag) {
			BetterList<string> invulnerableStats = new BetterList<string>();
			
			if(((aFlag&EMonsterStat.RangeAttack)==EMonsterStat.RangeAttack)&&((EMonsterStat.RangeAttack&this.invulnerableToChanges)==0)) {
				invulnerableToChanges = invulnerableToChanges | EMonsterStat.RangeAttack;
				invulnerableStats.Add("Range Attack");
				
			}
			if(((aFlag&EMonsterStat.RangeDefense)==EMonsterStat.RangeDefense)&&((EMonsterStat.RangeDefense&this.invulnerableToChanges)==0)) {
				invulnerableToChanges = invulnerableToChanges | EMonsterStat.RangeDefense;
				invulnerableStats.Add("Range Defense");
				
			}
			if(((aFlag&EMonsterStat.Speed)==EMonsterStat.Speed)&&((EMonsterStat.Speed&this.invulnerableToChanges)==0)) {
				invulnerableToChanges = invulnerableToChanges | EMonsterStat.Speed;
				invulnerableStats.Add("Speed");
				
			}
			if(((aFlag&EMonsterStat.Support)==EMonsterStat.Support)&&((EMonsterStat.Support&this.invulnerableToChanges)==0)) {
				invulnerableToChanges = invulnerableToChanges | EMonsterStat.Support;
				invulnerableStats.Add("Support");
				
			}
			
			if(invulnerableStats.size>0) {
				if(invulnerableStats.size==8) {
					this.doCommentaryMessage(this.name+" Became Invulnerable to All Stat Damages",ECommentaryMessageType.StandardMessage);
				} else {
					string s = createStatChangeString(invulnerableStats);
					this.doCommentaryMessage(this.name+" Became Invulnerable to "+s+" Changes",ECommentaryMessageType.StandardMessage);
				}
				return true;
			}
			return false;
		}
		public float applyStatEffectsFromMove(MoveLibItem aItem,MoveQueueItem aMoveQueueA) {
			float delayToAdd = 0.0f;
			BetterList<string> changedStatsUp = new BetterList<string>();
			BetterList<string> changedStatsDown = new BetterList<string>();
			removeWeaknessTo(aItem.removesWeaknessesTo);
			delayToAdd += doDecisiveBlowsChange(aItem.decisiveBlowsChangeMultiplier);
			delayToAdd += this.doAccuracyChange(aItem.accuracyMultiplier,changedStatsUp,changedStatsDown);
			delayToAdd += this.doAgilityChange(aItem.agilityMultiplier,changedStatsUp,changedStatsDown);
			delayToAdd += this.doSpeedChange(aItem.speedChangeMultiplier,changedStatsUp,changedStatsDown);
			delayToAdd += this.doMeleeDefChange(aItem.meleeDefenseMultiplier,changedStatsUp,changedStatsDown);
			delayToAdd += this.doRangeAtckChange(aItem.rangeAttackMultiplier,changedStatsUp,changedStatsDown);
			delayToAdd += this.doRangeDefChange(aItem.rangeDefenseMultiplier,changedStatsUp,changedStatsDown);
			delayToAdd += this.doMeleeAtckChange(aItem.meleeAttackMultiplier,changedStatsUp,changedStatsDown);

			if(changedStatsUp.size>0&&changedStatsDown.size==0) {
				this.doCommentaryMessage(createStatChangeString(changedStatsUp)+" Rose",ECommentaryMessageType.StandardMessage);
				this.doStatRaisingAnim();
			} else
			if(changedStatsDown.size>0&&changedStatsUp.size==0) {
				this.doCommentaryMessage(createStatChangeString(changedStatsDown)+" Fell",ECommentaryMessageType.StandardMessage);
				this.doStatLoweringAnim();
			} else if(changedStatsUp.size>0&&changedStatsDown.size>0) {
				string rising = createStatChangeString(changedStatsUp)+" Rose and "+createStatChangeString(changedStatsDown)+" Fell";
				this.doCommentaryMessage(rising,Battles.ECommentaryMessageType.StandardMessage);
			}
			if(this.doInvulnerableToChanges(aItem.addsInvulnerabilityStatTo)) {
				delayToAdd += delayPerItem;
			}
			return delayToAdd;
		}

		public void removeWeaknessTo(int aBinaryValue) {
			if(aBinaryValue>0) {
				BetterList<ElementalType> removedWeaknessElements = ElementalLibrary.REF.getElementsFromFlags(aBinaryValue);
				for(int i = 0;i<removedWeaknessElements.size;i++) {
					if(this.addRemovedWeakness(removedWeaknessElements[i])) {
						if(aBinaryValue!=255)
							this.doCommentaryMessage(this.name+" is no longer Vulnerable to any Moves of "+removedWeaknessElements[i].Name+" Type!",ECommentaryMessageType.StandardMessage);
					}
				}
				if(aBinaryValue==255) {
					this.doCommentaryMessage(this.name+" is no longer Vulnerable to any Move Type!",ECommentaryMessageType.StandardMessage);
				}
			}
		}
		public float applyStatEffectsFromMove(BattleBoostItem aItem,MoveQueueItem aMoveQueueA) {
			float delayToAdd = 0.0f;
			BetterList<string> changedStatsUp = new BetterList<string>();
			BetterList<string> changedStatsDown = new BetterList<string>();
			removeWeaknessTo(aItem.removesWeaknessesTo);
			delayToAdd += doDecisiveBlowsChange(aItem.decisiveBlowsChangeMultiplier);
			delayToAdd += this.doAccuracyChange(aItem.accuracyMultiplier,changedStatsUp,changedStatsDown);
			delayToAdd += this.doAgilityChange(aItem.agilityMultiplier,changedStatsUp,changedStatsDown);
			delayToAdd += this.doSpeedChange(aItem.speedMulti,changedStatsUp,changedStatsDown);
			delayToAdd += this.doMeleeDefChange(aItem.meleeDefMulti,changedStatsUp,changedStatsDown);
			delayToAdd += this.doRangeAtckChange(aItem.rangeAtckMulti,changedStatsUp,changedStatsDown);
			delayToAdd += this.doRangeDefChange(aItem.rangeDefMulti,changedStatsUp,changedStatsDown);
			delayToAdd += this.doMeleeAtckChange(aItem.meleeAtckMulti,changedStatsUp,changedStatsDown);
			
			if(changedStatsUp.size>0&&changedStatsDown.size==0) {
				this.doCommentaryMessage(createStatChangeString(changedStatsUp)+" Rose",ECommentaryMessageType.StandardMessage);
				this.doStatRaisingAnim();
			} else
			if(changedStatsDown.size>0&&changedStatsUp.size==0) {
				this.doCommentaryMessage(createStatChangeString(changedStatsDown)+" Fell",ECommentaryMessageType.StandardMessage);
				this.doStatLoweringAnim();
			} else {
				string rising = createStatChangeString(changedStatsUp)+" Rose and "+createStatChangeString(changedStatsDown)+" Fell";
				this.doCommentaryMessage(rising,Battles.ECommentaryMessageType.StandardMessage);
			}
			
			if(this.doInvulnerableToChanges(aItem.invulnerableToStatChange)) {
				delayToAdd += delayPerItem;
			}
			return delayToAdd;
		}
		
		
		public override float speed {
			get {
				return (this._speedEffector*base.speed);
			}
		}
		
		public override int agility {
			get {
				return (int) (this._agilityEffector*base.agility);
			}
		}
		public override int rangeAttack {
			get {
				return (int) (this._rangeAttackEffector*base.rangeAttack);
			}
		}
		
		public override int rangeDefense {
			get {
				return (int) (this._rangeDefenseEffector*base.rangeDefense);
			}
		}
		
		public override int meleeDefense {
			get {
				BattleBase.DebugText("BattleMonsterWithBattleEffects->Getting Melee Defence ("+this.monster.name+") : "+_meleeDefenseEffector+" / "+base.meleeDefense);
				
				return (int) (this._meleeDefenseEffector*base.meleeDefense);
			}
		}
		
		public override int meleeAttack {
			get {
				return (int) (this._meleeAttackEffector*base.meleeAttack);
			}
		}
		
		public override int accuracy {
			get {
				return (int) (this._accuracyEffector*base.accuracy);
			}
		}
		
		
		
	}
}

